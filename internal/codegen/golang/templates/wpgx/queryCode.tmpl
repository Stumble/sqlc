{{define "queryCodeWPgx"}}
{{range .GoQueries}}
{{if $.OutputQuery .SourceName}}
{{if and (ne .Cmd ":copyfrom") (ne (hasPrefix .Cmd ":batch") true)}}
const {{.ConstantName}} = {{$.Q}}-- name: {{.MethodName}} {{.Cmd}}
{{escape .SQL}}
{{$.Q}}
{{end}}

{{if ne (hasPrefix .Cmd ":batch") true}}
{{if .Arg.EmitStruct}}
type {{.Arg.Type}} struct { {{- range .Arg.Struct.Fields}}
  {{.Name}} {{.Type}} {{if .Tag}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}

{{if (ne .Cmd ":copyfrom")}}
// CacheKey - cache key
func ({{.Arg.Name}} {{.Arg.Type}}) CacheKey() string {
    prefix := "{{.MethodName}}:"
	return prefix + fmt.Sprintf({{.Arg.CacheKeySprintf}})
}
{{end}}

{{end}}

{{if .Ret.EmitStruct}}
type {{.Ret.Type}} struct { {{- range .Ret.Struct.Fields}}
  {{.Name}} {{.Type}} {{if .Tag}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}
{{end}}

{{if eq .Cmd ":one"}}
{{range .Comments}}//{{.}}
{{end -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}} {{.InvalidateArgs}}) (*{{.Ret.Type}}, error) {
	// TODO(mustRevalidate, noStore)
	dbRead := func() (any, time.Duration, error) {
        cacheDuration := time.Duration(time.Millisecond * {{.Option.Cache.Milliseconds}})
        row := q.db.WQueryRow(ctx, "{{.MethodName}}", {{.ConstantName}},
            {{.Arg.Params}})
	    {{.Ret.Name}} := &{{.Ret.Type}}{}
	    err := row.Scan({{.Ret.Scan}})
        if err == pgx.ErrNoRows {
            return nil, cacheDuration, nil
        }
	    return {{.Ret.Name}}, cacheDuration, err
    }
	if q.cache == nil {
		rv, _, err := dbRead()
		return rv.(*{{.Ret.Type}}), err
	}

	var rv *{{.Ret.Type}}
	err := q.cache.GetWithTtl(ctx, {{.CacheKey}}, &rv, dbRead, false, false)
	if err != nil {
		return nil, err
	}

    {{ if  .Option.Invalidates -}}
    // invalidate
	invalidateErr := q.db.PostExec(func() error {
        var anyErr error
        {{ range .Invalidates -}}
        if {{.ArgName}} != nil {
		    err = q.cache.Invalidate(ctx, {{.CacheKey}})
            if err != nil {
                anyErr = err
            }
        }
        {{ end -}}
        return anyErr
	})
    if invalidateErr != nil {
        // invalidateErr is ignored for now.
    }
    {{- end }}

	return rv, err
}
{{end}}

{{if eq .Cmd ":many"}}
{{range .Comments}}//{{.}}
{{end -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}} {{.InvalidateArgs}}) ([]{{.Ret.DefineType}}, error) {
	dbRead := func() (any, time.Duration, error) {
        cacheDuration := time.Duration(time.Millisecond * {{.Option.Cache.Milliseconds}})
        rows, err := q.db.WQuery(ctx, "{{.MethodName}}", {{.ConstantName}}, {{.Arg.Params}})
		if err != nil {
			return nil, 0, err
		}
		defer rows.Close()
	    var items []{{.Ret.DefineType}}
		for rows.Next() {
		    var {{.Ret.Name}} {{.Ret.Type}}
		    if err := rows.Scan({{.Ret.Scan}}); err != nil {
			    return nil, 0, err
		    }
		    items = append(items, {{.Ret.ReturnName}})
		}
		if err := rows.Err(); err != nil {
			return nil, 0, err
		}
		return items, cacheDuration, nil
	}
	if q.cache == nil {
		items, _, err := dbRead()
		return items.([]{{.Ret.DefineType}}), err
	}

	var items []{{.Ret.DefineType}}
	err := q.cache.GetWithTtl(ctx, {{.CacheKey}}, &items, dbRead, false, false)
	if err != nil {
		return nil, err
	}

    {{ if  .Option.Invalidates -}}
    // invalidate
	invalidateErr := q.db.PostExec(func() error {
        var anyErr error
        {{ range .Invalidates -}}
        if {{.ArgName}} != nil {
		    err = q.cache.Invalidate(ctx, {{.CacheKey}})
            if err != nil {
                anyErr = err
            }
        }
        {{ end -}}
        return anyErr
	})
    if invalidateErr != nil {
        // invalidateErr is ignored for now.
    }
    {{- end }}

	return items, err
}
{{end}}

{{if eq .Cmd ":exec"}}
{{range .Comments}}//{{.}}
{{end -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}} {{.InvalidateArgs}}) error {
	_, err := q.db.WExec(ctx, "{{.MethodName}}", {{.ConstantName}}, {{.Arg.Params}})
    if err != nil {
        return err
    }

    {{ if  .Option.Invalidates -}}
    // invalidate
	invalidateErr := q.db.PostExec(func() error {
        var anyErr error
        {{ range .Invalidates -}}
        if {{.ArgName}} != nil {
		    err = q.cache.Invalidate(ctx, {{.CacheKey}})
            if err != nil {
                anyErr = err
            }
        }
        {{ end -}}
        return anyErr
	})
    if invalidateErr != nil {
        // invalidateErr is ignored for now.
    }
    {{- end }}

    return nil
}
{{end}}

{{if eq .Cmd ":execrows"}}
{{range .Comments}}//{{.}}
{{end -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}} {{.InvalidateArgs}}) (int64, error) {
	result, err := q.db.WExec(ctx, "{{.MethodName}}", {{.ConstantName}}, {{.Arg.Params}})
	if err != nil {
		return 0, err
	}

    {{ if  .Option.Invalidates -}}
    // invalidate
	invalidateErr := q.db.PostExec(func() error {
        var anyErr error
        {{ range .Invalidates -}}
        if {{.ArgName}} != nil {
		    err = q.cache.Invalidate(ctx, {{.CacheKey}})
            if err != nil {
                anyErr = err
            }
        }
        {{ end -}}
        return anyErr
	})
    if invalidateErr != nil {
        // invalidateErr is ignored for now.
    }
    {{- end }}

	return result.RowsAffected(), nil
}
{{end}}

{{if eq .Cmd ":execresult"}}
{{range .Comments}}//{{.}}
{{end -}}
func (q *Queries) {{.MethodName}}(ctx context.Context, {{.Arg.Pair}} {{.InvalidateArgs}}) (pgconn.CommandTag, error) {
	rv, err := q.db.WExec(ctx, "{{.MethodName}}", {{.ConstantName}}, {{.Arg.Params}})
	if err != nil {
		return rv, err
	}

    {{ if  .Option.Invalidates -}}
    // invalidate
	invalidateErr := q.db.PostExec(func() error {
        var anyErr error
        {{ range .Invalidates -}}
        if {{.ArgName}} != nil {
		    err = q.cache.Invalidate(ctx, {{.CacheKey}})
            if err != nil {
                anyErr = err
            }
        }
        {{ end -}}
        return anyErr
	})
    if invalidateErr != nil {
        // invalidateErr is ignored for now.
    }
    {{- end }}

    return rv, nil
}
{{end}}


{{end}}
{{end}}

//// auto generated functions

func (q *Queries) Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error) {
	sql := "{{.DumpLoader.DumpSQL}}"
	rows, err := q.db.WQuery(ctx, "Dump", sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []{{.DumpLoader.MainStructName}}
	for rows.Next() {
		var v {{.DumpLoader.MainStructName}}
		if err := rows.Scan({{.DumpLoader.Fields "&v."}}); err != nil {
			return nil, err
		}
		for _, applyBeforeDump := range beforeDump {
			applyBeforeDump(&v)
		}
		items = append(items, v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	bytes, err := json.MarshalIndent(items, "", "  ")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func (q *Queries) Load(ctx context.Context, data []byte) error {
    sql := "{{.DumpLoader.LoadSQL}}"
	rows := make([]{{.DumpLoader.MainStructName}}, 0)
	err := json.Unmarshal(data, &rows)
	if err != nil {
		return err
	}
	for _, row := range rows {
		_, err := q.db.WExec(ctx, "Load", sql, {{.DumpLoader.Fields "row."}})
		if err != nil {
			return err
		}
	}
	return nil
}

{{end}}
