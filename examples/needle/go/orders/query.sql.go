// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package orders

import (
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v5"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO Orders (
  UserID, ItemID, IsDeleted
) VALUES (
  $1, $2, FALSE
)
RETURNING id, userid, itemid, createdat, isdeleted
`

type CreateAuthorParams struct {
	Userid int32
	Itemid int32
}

// CacheKey - cache key
func (arg CreateAuthorParams) CacheKey() string {
	prefix := "CreateAuthor:"
	return prefix + fmt.Sprintf("%+v,%+v", arg.Userid, arg.Itemid)
}

func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (*Order, error) {
	// TODO(mustRevalidate, noStore)
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 0)
		row := q.db.WQueryRow(ctx, "CreateAuthor", createAuthor,
			arg.Userid, arg.Itemid)
		i := &Order{}
		err := row.Scan(
			&i.ID,
			&i.Userid,
			&i.Itemid,
			&i.Createdat,
			&i.Isdeleted,
		)
		if err == pgx.ErrNoRows {
			return nil, cacheDuration, nil
		}
		return i, cacheDuration, err
	}
	if q.cache == nil {
		rv, _, err := dbRead()
		return rv.(*Order), err
	}

	var rv *Order
	err := q.cache.GetWithTtl(ctx, arg.CacheKey(), &rv, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return rv, err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE Orders
SET
  IsDeleted = TRUE
WHERE
  id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int32) error {
	_, err := q.db.WExec(ctx, "DeleteOrder", deleteOrder, id)
	if err != nil {
		return err
	}

	return nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT
  Orders.ID,
  Orders.UserID,
  Orders.ItemID,
  Orders.CreatedAt,
  Users.Name AS UserName,
  Users.Thumbnail AS UserThumbnail,
  Items.Name AS ItemName,
  Items.Description As ItemDesc,
  Items.Price As ItemPrice,
  Items.Thumbnail As ItemThumbnail,
  Items.Metadata As ItemMetadata
FROM
  Orders
  INNER JOIN Items ON Orders.ItemID = Items.ID
  INNER JOIN Users ON Orders.UserID = Users.ID
WHERE
  Orders.IsDeleted = FALSE
`

type GetOrderByIDRow struct {
	ID            int32
	Userid        int32
	Itemid        int32
	Createdat     time.Time
	Username      string
	Userthumbnail string
	Itemname      string
	Itemdesc      string
	Itemprice     pgtype.Numeric
	Itemthumbnail string
	Itemmetadata  []byte
}

// -- cache : 10m
func (q *Queries) GetOrderByID(ctx context.Context) (*GetOrderByIDRow, error) {
	// TODO(mustRevalidate, noStore)
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 600000)
		row := q.db.WQueryRow(ctx, "GetOrderByID", getOrderByID)
		i := &GetOrderByIDRow{}
		err := row.Scan(
			&i.ID,
			&i.Userid,
			&i.Itemid,
			&i.Createdat,
			&i.Username,
			&i.Userthumbnail,
			&i.Itemname,
			&i.Itemdesc,
			&i.Itemprice,
			&i.Itemthumbnail,
			&i.Itemmetadata,
		)
		if err == pgx.ErrNoRows {
			return nil, cacheDuration, nil
		}
		return i, cacheDuration, err
	}
	if q.cache == nil {
		rv, _, err := dbRead()
		return rv.(*GetOrderByIDRow), err
	}

	var rv *GetOrderByIDRow
	err := q.cache.GetWithTtl(ctx, "GetOrderByID", &rv, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return rv, err
}

const listOrdersByGender = `-- name: ListOrdersByGender :many
WITH UsersByGender AS (
  SELECT id, name, metadata, thumbnail, createdat FROM Users WHERE Users.Metadata->>'gender' = $3::text
)
SELECT id, userid, itemid, createdat, isdeleted FROM Orders
WHERE
  UserId IN (SELECT id FROM UsersByGender) AND Orders.ID > $1
LIMIT $2
`

type ListOrdersByGenderParams struct {
	After  int32
	First  int32
	Gender string
}

// CacheKey - cache key
func (arg ListOrdersByGenderParams) CacheKey() string {
	prefix := "ListOrdersByGender:"
	return prefix + fmt.Sprintf("%+v,%+v,%+v", arg.After, arg.First, arg.Gender)
}

// -- cache : 1m
// This is just an example for using type annotation for JSON field and 'with clause'.
func (q *Queries) ListOrdersByGender(ctx context.Context, arg ListOrdersByGenderParams) ([]Order, error) {
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 60000)
		rows, err := q.db.WQuery(ctx, "ListOrdersByGender", listOrdersByGender, arg.After, arg.First, arg.Gender)
		if err != nil {
			return nil, 0, err
		}
		defer rows.Close()
		var items []Order
		for rows.Next() {
			var i Order
			if err := rows.Scan(
				&i.ID,
				&i.Userid,
				&i.Itemid,
				&i.Createdat,
				&i.Isdeleted,
			); err != nil {
				return nil, 0, err
			}
			items = append(items, i)
		}
		if err := rows.Err(); err != nil {
			return nil, 0, err
		}
		return items, cacheDuration, nil
	}
	if q.cache == nil {
		items, _, err := dbRead()
		return items.([]Order), err
	}

	var items []Order
	err := q.cache.GetWithTtl(ctx, arg.CacheKey(), &items, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return items, err
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT id, userid, itemid, createdat, isdeleted FROM Orders
WHERE
  UserID = $1 AND CreatedAt < $2
ORDER BY CreatedAt DESC
LIMIT $3
`

type ListOrdersByUserParams struct {
	Userid int32
	After  time.Time
	First  int32
}

// CacheKey - cache key
func (arg ListOrdersByUserParams) CacheKey() string {
	prefix := "ListOrdersByUser:"
	return prefix + fmt.Sprintf("%+v,%+v,%+v", arg.Userid, arg.After, arg.First)
}

func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]Order, error) {
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 0)
		rows, err := q.db.WQuery(ctx, "ListOrdersByUser", listOrdersByUser, arg.Userid, arg.After, arg.First)
		if err != nil {
			return nil, 0, err
		}
		defer rows.Close()
		var items []Order
		for rows.Next() {
			var i Order
			if err := rows.Scan(
				&i.ID,
				&i.Userid,
				&i.Itemid,
				&i.Createdat,
				&i.Isdeleted,
			); err != nil {
				return nil, 0, err
			}
			items = append(items, i)
		}
		if err := rows.Err(); err != nil {
			return nil, 0, err
		}
		return items, cacheDuration, nil
	}
	if q.cache == nil {
		items, _, err := dbRead()
		return items.([]Order), err
	}

	var items []Order
	err := q.cache.GetWithTtl(ctx, arg.CacheKey(), &items, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return items, err
}
