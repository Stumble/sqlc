// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package orders

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO Orders (
  UserID, ItemID, IsDeleted
) VALUES (
  $1, $2, FALSE
)
RETURNING id, userid, itemid, createdat, isdeleted
`

type CreateAuthorParams struct {
	Userid int32
	Itemid int32
}

func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (Order, error) {
	row := q.db.QueryRow(ctx, createAuthor, arg.Userid, arg.Itemid)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Itemid,
		&i.Createdat,
		&i.Isdeleted,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE Orders
SET
  IsDeleted = TRUE
WHERE
  id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT
  Orders.ID,
  Orders.UserID,
  Orders.ItemID,
  Orders.CreatedAt,
  Users.Name AS UserName,
  Users.Thumbnail AS UserThumbnail,
  Items.Name AS ItemName,
  Items.Description As ItemDesc,
  Items.Price As ItemPrice,
  Items.Thumbnail As ItemThumbnail,
  Items.Metadata As ItemMetadata
FROM
  Orders
  INNER JOIN Items ON Orders.ItemID = Items.ID
  INNER JOIN Users ON Orders.UserID = Users.ID
WHERE
  Orders.IsDeleted = FALSE
`

type GetOrderByIDRow struct {
	ID            int32
	Userid        int32
	Itemid        int32
	Createdat     pgtype.Timestamp
	Username      string
	Userthumbnail string
	Itemname      string
	Itemdesc      string
	Itemprice     pgtype.Numeric
	Itemthumbnail string
	Itemmetadata  []byte
}

// -- cache : 10m
func (q *Queries) GetOrderByID(ctx context.Context) (GetOrderByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderByID)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Itemid,
		&i.Createdat,
		&i.Username,
		&i.Userthumbnail,
		&i.Itemname,
		&i.Itemdesc,
		&i.Itemprice,
		&i.Itemthumbnail,
		&i.Itemmetadata,
	)
	return i, err
}

const listOrdersByGender = `-- name: ListOrdersByGender :many
WITH UsersByGender AS (
  SELECT id, name, metadata, thumbnail, createdat FROM Users WHERE Users.Metadata->>'gender' = $3::text
)
SELECT id, userid, itemid, createdat, isdeleted FROM Orders
WHERE
  UserId IN (SELECT id FROM UsersByGender) AND Orders.ID > $1
LIMIT $2
`

type ListOrdersByGenderParams struct {
	After  int32
	First  int32
	Gender string
}

// -- cache : 1m
// This is just an example for using type annotation for JSON field and 'with clause'.
func (q *Queries) ListOrdersByGender(ctx context.Context, arg ListOrdersByGenderParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByGender, arg.After, arg.First, arg.Gender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Itemid,
			&i.Createdat,
			&i.Isdeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT id, userid, itemid, createdat, isdeleted FROM Orders
WHERE
  UserID = $1 AND CreatedAt < $2
ORDER BY CreatedAt DESC
LIMIT $3
`

type ListOrdersByUserParams struct {
	Userid int32
	After  pgtype.Timestamp
	First  int32
}

func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByUser, arg.Userid, arg.After, arg.First)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Itemid,
			&i.Createdat,
			&i.Isdeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
